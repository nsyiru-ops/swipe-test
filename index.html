<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Swipe Video Scrub</title>

  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000;
      overflow: hidden;
      touch-action: none;
      overscroll-behavior: none;
    }
    :root { --vh: 1vh; }

    #stage {
      position: fixed;
      inset: 0;
      width: 100%;
      height: calc(var(--vh) * 100);
      display: flex;
      align-items: center;
      justify-content: center;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      box-sizing: border-box;
      background: #000;
      user-select: none;
      -webkit-user-select: none;
    }

    /* ✅ 발 안 잘리게: contain */
    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      display: block;
    }

    /* ✅ iOS에서 poster가 사라지며 검정되는 문제 방지용 오버레이 */
    #posterOverlay {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      display: block;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="stage">
    <video id="v"
      playsinline webkit-playsinline
      preload="auto"
      muted
    ></video>
    <img id="posterOverlay" src="poster.jpg" alt="">
  </div>

<script>
  // ✅ Netlify mp4
  const VIDEO_URL = "https://zippy-flan-5b618a.netlify.app/video.mp4";

  const stage = document.getElementById('stage');
  const video = document.getElementById('v');
  const poster = document.getElementById('posterOverlay');

  video.src = VIDEO_URL;

  // iOS 주소창 높이 변화 대응
  function setVh(){
    const h = (window.visualViewport?.height ?? window.innerHeight);
    document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
  }
  window.addEventListener('resize', setVh, {passive:true});
  window.visualViewport?.addEventListener('resize', setVh, {passive:true});
  setVh();

  // ===== 스크럽 파라미터 (끊김/속도 조절) =====
  const SECONDS_PER_PX = 0.0009;   // ✅ 민감도 (값 ↑ 더 빠름 / 값 ↓ 더 느림)
  const FRICTION = 0.90;           // ✅ 관성 감속 (값 ↑ 더 오래 미끄러짐)
  const STOP_V = 0.00002;          // ✅ 멈춤 임계치

  let unlocked = false;
  let ready = false;
  let duration = 0;

  // 스와이프 상태
  let dragging = false;
  let lastX = 0;
  let lastT = 0;
  let velSecPerMs = 0;

  // 부드럽게: move 이벤트마다 currentTime 때리지 않고 rAF에서 1회만 반영
  let desiredTime = 0;
  let applyRaf = null;

  function getDuration(){
    const d = video.duration;
    if (isFinite(d) && d > 0) return d;
    // iOS에서 duration이 Infinity/NaN일 때 대비
    try {
      if (video.seekable && video.seekable.length) return video.seekable.end(0);
    } catch(e){}
    return 0;
  }

  function wrapTime(t){
    if(!duration || !isFinite(duration)) return 0;
    t = t % duration;
    if(t < 0) t += duration;
    return t;
  }

  function scheduleApply(){
    if(applyRaf) return;
    applyRaf = requestAnimationFrame(() => {
      applyRaf = null;
      if(!ready) return;
      const t = wrapTime(desiredTime);
      // currentTime 설정이 iOS에서 가끔 throw 할 수 있어서 보호
      try { video.currentTime = t; } catch(e) {}
    });
  }

  async function unlockVideoOnce(){
    if(unlocked) return;
    unlocked = true;

    // ✅ iOS 핵심: 유저 제스처 안에서 play → pause 한 번 해줘야 스크럽이 안정적으로 먹음
    try{
      video.muted = true;
      await video.play();
      video.pause();
    } catch(e){
      // 그래도 진행 (일부 환경은 정책/네트워크에 따라 실패할 수 있음)
    }

    // 메타/시킹 준비될 때까지 기다렸다가 첫 프레임 띄우고 poster 오버레이 숨김
    const tryReady = () => {
      duration = getDuration();
      if(duration > 0){
        ready = true;
        desiredTime = 0.001; // 0은 검정 나오는 경우가 있어 약간 띄움
        scheduleApply();
        // 프레임이 실제로 뜰 시간을 조금 주고 오버레이 제거
        setTimeout(() => { poster.style.display = "none"; }, 80);
      }
    };

    tryReady();
    // canplay/loadedmetadata 둘 다 훅
    const onMeta = () => { tryReady(); };
    video.addEventListener('loadedmetadata', onMeta, {once:true});
    video.addEventListener('canplay', onMeta, {once:true});

    // 혹시 지연되면 재시도
    setTimeout(tryReady, 200);
    setTimeout(tryReady, 600);
  }

  function stopInertia(){
    if(inertiaRaf) cancelAnimationFrame(inertiaRaf);
    inertiaRaf = null;
  }

  let inertiaRaf = null;
  function startInertia(){
    stopInertia();
    let prev = performance.now();

    const step = (now)=>{
      const dt = now - prev;
      prev = now;

      if(Math.abs(velSecPerMs) < STOP_V){
        velSecPerMs = 0;
        inertiaRaf = null;
        return;
      }

      desiredTime = (video.currentTime || 0) + velSecPerMs * dt;
      scheduleApply();

      // 감속
      const f = Math.pow(FRICTION, dt / 16.67);
      velSecPerMs *= f;

      inertiaRaf = requestAnimationFrame(step);
    };

    inertiaRaf = requestAnimationFrame(step);
  }

  function onDown(x){
    unlockVideoOnce();   // ✅ 첫 터치에서 언락
    dragging = true;
    lastX = x;
    lastT = performance.now();
    velSecPerMs = 0;
    stopInertia();
  }

  function onMove(x){
    if(!dragging) return;
    if(!ready) return;

    const now = performance.now();
    const dx = x - lastX;
    const dt = now - lastT;

    // ✅ 양방향 + 루프 느낌: 시작/끝에서 안 먹는 구간 제거
    const deltaSec = (-dx) * SECONDS_PER_PX;
    desiredTime = (video.currentTime || 0) + deltaSec;
    scheduleApply();

    if(dt > 0) velSecPerMs = (deltaSec / dt);

    lastX = x;
    lastT = now;
  }

  function onUp(){
    if(!dragging) return;
    dragging = false;
    startInertia();   // ✅ 손 떼면 관성
  }

  // Pointer events
  stage.addEventListener('pointerdown', (e)=>{
    stage.setPointerCapture?.(e.pointerId);
    onDown(e.clientX);
  }, {passive:false});

  stage.addEventListener('pointermove', (e)=>{
    e.preventDefault();
    onMove(e.clientX);
  }, {passive:false});

  stage.addEventListener('pointerup', onUp, {passive:true});
  stage.addEventListener('pointercancel', onUp, {passive:true});

  // Touch fallback
  stage.addEventListener('touchstart', (e)=>{
    if(!e.touches?.length) return;
    onDown(e.touches[0].clientX);
  }, {passive:false});

  stage.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    if(!e.touches?.length) return;
    onMove(e.touches[0].clientX);
  }, {passive:false});

  stage.addEventListener('touchend', onUp, {passive:true});
  stage.addEventListener('touchcancel', onUp, {passive:true});

  // 혹시 로드되면 준비 (언락 전에는 iOS에서 제대로 안 잡힐 수 있음)
  video.addEventListener('loadedmetadata', ()=>{
    duration = getDuration();
    ready = (duration > 0);
  });

  video.addEventListener('error', ()=>{
    console.log("Video error:", video.error);
    ready = false;
    // 에러 시 poster 유지
    poster.style.display = "block";
  });
</script>
</body>
</html>
