<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Swipe Video Scrub</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000;
      overflow: hidden; /* 스크롤로 스와이프가 먹히는 것 방지 */
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      touch-action: none; /* 중요: iOS에서 기본 스크롤/뒤로가기 제스처 억제 */
    }

    /* iOS 주소창/툴바에 가리지 않게: innerHeight 기반 --vh 사용 */
    :root { --vh: 1vh; }

    #stage {
      position: fixed;
      inset: 0;
      width: 100%;
      height: calc(var(--vh) * 100);
      display: flex;
      align-items: center;
      justify-content: center;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      box-sizing: border-box;
      background: #000;
    }

    /* "구두까지 다 보이게": contain으로 전체가 화면 안에 들어오게 */
    video {
      width: 100%;
      height: 100%;
      object-fit: contain; /* ✅ 전체가 보이도록 (잘림 방지) */
      display: block;
      background: #000;
    }

    /* 로딩/에러 안내(원하면 나중에 지워도 됨) */
    #overlay {
      position: fixed;
      left: 0; right: 0;
      bottom: calc(env(safe-area-inset-bottom) + 14px);
      display: flex;
      justify-content: center;
      pointer-events: none;
      z-index: 10;
      font: 14px/1.2 -apple-system, system-ui, sans-serif;
      color: rgba(255,255,255,0.85);
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
    }
    #overlay > div{
      background: rgba(0,0,0,0.35);
      padding: 8px 12px;
      border-radius: 999px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    /* ✅ 하단 문구 없애고 싶으면: 아래 주석 해제하면 끝
       (요청 3번: 완전 제거) */
    /* #overlay { display:none !important; } */
  </style>
</head>

<body>
  <div id="stage">
    <video id="v"
      src="video.mp4"
      poster="poster.jpg"
      playsinline
      webkit-playsinline
      preload="auto"
      muted
    ></video>
  </div>

  <!-- 하단 문구(원하면 CSS에서 display:none 처리) -->
  <div id="overlay"><div id="msg">로딩중… (처음 1회 터치로 준비)</div></div>

  <script>
    const video = document.getElementById('v');
    const msg = document.getElementById('msg');

    // ✅ 주소창/툴바 영역에 가리지 않게(가장 효과 큼)
    function setVh() {
      document.documentElement.style.setProperty('--vh', (window.innerHeight * 0.01) + 'px');
    }
    window.addEventListener('resize', setVh, { passive: true });
    setVh();

    // =========================
    // 스와이프 → currentTime 스크럽 + 관성
    // =========================
    let duration = 0;
    let ready = false;
    let primed = false;

    // 속도 튜닝 포인트 (요청: 관성이 너무 빨라 → 더 천천히)
    const SECONDS_PER_PX = 0.0022; // ✅ 작을수록 "천천히" 움직임 (0.0018~0.003 사이로 조절)
    const FRICTION = 0.92;         // ✅ 관성 감속(0.90~0.96). 숫자 높을수록 오래 감.
    const STOP_V = 0.00002;        // 관성 정지 임계값(작을수록 오래 감)

    let dragging = false;
    let lastX = 0;
    let lastT = 0;
    let vSecPerMs = 0;  // 관성용 속도 (초/밀리초)
    let rafId = null;

    function wrapTime(t) {
      if (!duration || !isFinite(duration)) return 0;
      // ✅ 끝/처음에서 막히지 않게 "루프 스크럽"
      t = t % duration;
      if (t < 0) t += duration;
      return t;
    }

    function setTime(t) {
      if (!ready) return;
      const nt = wrapTime(t);
      // iOS에서 너무 자주 set하면 버벅일 수 있어서 약간 문턱
      if (Math.abs((video.currentTime || 0) - nt) > 0.0005) {
        video.currentTime = nt;
      }
    }

    async function primeVideoOnce() {
      if (primed) return;
      primed = true;

      // iOS에서 "poster만 보이는" 케이스를 줄이기 위한 1회 준비.
      // ✅ 사용자의 터치(제스처) 안에서 play->pause를 짧게 실행하면 디코드가 풀리는 경우가 많음.
      try {
        msg.textContent = "준비 중…";
        video.muted = true;
        const p = video.play();
        if (p && p.then) await p;
        video.pause();
        // 첫 프레임 확실히 표시
        setTime(video.currentTime || 0);
        msg.textContent = ""; // 로딩 문구 제거
      } catch (e) {
        // 그래도 스크럽 자체는 될 수 있으니 안내만
        msg.textContent = "터치로 재생 권한이 필요할 수 있어요";
      }
    }

    function stopInertia() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    }

    function startInertia() {
      stopInertia();
      let prev = performance.now();
      const step = (now) => {
        const dt = now - prev;
        prev = now;

        // 속도로 진행
        if (Math.abs(vSecPerMs) < STOP_V) {
          vSecPerMs = 0;
          rafId = null;
          return;
        }

        const next = (video.currentTime || 0) + vSecPerMs * dt;
        setTime(next);

        // 감속
        // dt가 커도 자연스럽게 감속되도록 지수 형태로
        const f = Math.pow(FRICTION, dt / 16.67);
        vSecPerMs *= f;

        rafId = requestAnimationFrame(step);
      };
      rafId = requestAnimationFrame(step);
    }

    function onDown(clientX) {
      primeVideoOnce();
      dragging = true;
      lastX = clientX;
      lastT = performance.now();
      vSecPerMs = 0;
      stopInertia();
    }

    function onMove(clientX) {
      if (!dragging || !ready) return;

      const now = performance.now();
      const dx = clientX - lastX;
      const dt = now - lastT;

      // 왼쪽으로 드래그하면 앞으로(+) 진행, 오른쪽이면 뒤로(-)
      const deltaSec = (-dx) * SECONDS_PER_PX;
      setTime((video.currentTime || 0) + deltaSec);

      // 관성 속도(초/밀리초)
      if (dt > 0) {
        vSecPerMs = (deltaSec / dt);
      }

      lastX = clientX;
      lastT = now;
    }

    function onUp() {
      if (!dragging) return;
      dragging = false;
      // 손을 "휙 던지면" 관성으로 더 가다가 서서히 멈춤
      startInertia();
    }

    // Pointer Events 우선 (대부분 iOS/Android 최신 OK)
    const stage = document.getElementById('stage');

    stage.addEventListener('pointerdown', (e) => {
      stage.setPointerCapture?.(e.pointerId);
      onDown(e.clientX);
    }, { passive: false });

    stage.addEventListener('pointermove', (e) => {
      // 스크롤/뒤로가기 제스처 방지
      e.preventDefault();
      onMove(e.clientX);
    }, { passive: false });

    stage.addEventListener('pointerup', (e) => { onUp(); }, { passive: true });
    stage.addEventListener('pointercancel', (e) => { onUp(); }, { passive: true });

    // (보험) Touch fallback
    stage.addEventListener('touchstart', (e) => {
      if (e.touches && e.touches[0]) onDown(e.touches[0].clientX);
    }, { passive: true });

    stage.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches && e.touches[0]) onMove(e.touches[0].clientX);
    }, { passive: false });

    stage.addEventListener('touchend', () => onUp(), { passive: true });
    stage.addEventListener('touchcancel', () => onUp(), { passive: true });

    // 비디오 로딩 상태
    function markReady() {
      duration = video.duration || 0;
      if (duration && isFinite(duration)) {
        ready = true;
        msg.textContent = ""; // 로딩 문구 제거
      }
    }

    video.addEventListener('loadedmetadata', () => {
      markReady();
      // 첫 프레임 표시 강제(가끔 poster만 보이는 케이스 줄임)
      setTime(video.currentTime || 0);
    });

    video.addEventListener('canplay', () => {
      markReady();
    });

    video.addEventListener('error', () => {
      ready = false;
      msg.textContent = "video.mp4 로드 실패 (경로/파일명/업로드 확인)";
    });

    // 혹시 로딩이 느릴 때 안내
    setTimeout(() => {
      if (!ready) msg.textContent = "로딩중… (처음 1회 터치 필요)";
    }, 300);
  </script>
</body>
</html>
