<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Swipe Video Scrub</title>

  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000;
      overflow: hidden;
      touch-action: none;
    }

    :root { --vh: 1vh; }

    /* 화면 전체 + iOS 주소창/툴바 변화 대응 */
    #stage {
      position: fixed;
      inset: 0;
      width: 100%;
      height: calc(var(--vh) * 100);
      display: flex;
      align-items: center;
      justify-content: center;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      box-sizing: border-box;
      background: #000;
      -webkit-user-select: none;
      user-select: none;
    }

    /* ✅ 발이 안 잘리게: contain */
    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: #000;
      display: block;
    }
  </style>
</head>

<body>
  <div id="stage">
    <video id="v"
      playsinline webkit-playsinline
      preload="auto"
      muted
      poster="poster.jpg"
    ></video>
  </div>

<script>
  // ✅ Netlify mp4 직접 링크 (네가 준 주소 그대로)
  const VIDEO_URL = "https://zippy-flan-5b618a.netlify.app/video.mp4";

  const stage = document.getElementById('stage');
  const video = document.getElementById('v');
  video.src = VIDEO_URL;

  // iOS 주소창/툴바로 100vh가 흔들리는 문제 대응 (visualViewport 우선)
  function setVh(){
    const h = (window.visualViewport?.height ?? window.innerHeight);
    document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
  }
  window.addEventListener('resize', setVh, {passive:true});
  window.visualViewport?.addEventListener('resize', setVh, {passive:true});
  setVh();

  let ready = false;
  let duration = 0;
  let primed = false;

  // ===== 스와이프/관성(너무 빠르다 → 더 느리게) =====
  const SECONDS_PER_PX = 0.0011;  // ✅ 천천히(값 ↓ = 더 느림)
  const FRICTION = 0.92;          // ✅ 감속(값 ↑ = 더 오래 미끄러짐)
  const STOP_V = 0.00002;         // ✅ 멈춤 임계치

  let dragging = false;
  let lastX = 0;
  let lastT = 0;
  let vSecPerMs = 0;
  let rafId = null;

  function wrapTime(t){
    if(!duration || !isFinite(duration)) return 0;
    t = t % duration;
    if(t < 0) t += duration;
    return t;
  }
  function setTime(t){
    if(!ready) return;
    video.currentTime = wrapTime(t);
  }

  async function primeOnce(){
    if(primed) return;
    primed = true;
    try{
      // iOS에서 프레임 표시/시킹 안정화용 1회 play-pause (유저 제스처 안에서 호출)
      await video.play();
      video.pause();
    }catch(e){
      // iOS 정책으로 막혀도 스크럽은 시도됨
    }
  }

  function stopInertia(){
    if(rafId) cancelAnimationFrame(rafId);
    rafId = null;
  }
  function startInertia(){
    stopInertia();
    let prev = performance.now();

    const step = (now)=>{
      const dt = now - prev;
      prev = now;

      if(Math.abs(vSecPerMs) < STOP_V){
        vSecPerMs = 0;
        rafId = null;
        return;
      }

      setTime((video.currentTime || 0) + vSecPerMs * dt);

      // 프레임레이트 보정 감속
      const f = Math.pow(FRICTION, dt / 16.67);
      vSecPerMs *= f;

      rafId = requestAnimationFrame(step);
    };

    rafId = requestAnimationFrame(step);
  }

  function onDown(x){
    primeOnce();
    dragging = true;
    lastX = x;
    lastT = performance.now();
    vSecPerMs = 0;
    stopInertia();
  }

  function onMove(x){
    if(!dragging || !ready) return;

    const now = performance.now();
    const dx = x - lastX;
    const dt = now - lastT;

    // ✅ 어느 방향이든 루프처럼 계속 진행(시작/끝에서 “안 먹히는 구간” 제거)
    const deltaSec = (-dx) * SECONDS_PER_PX;
    setTime((video.currentTime || 0) + deltaSec);

    if(dt > 0) vSecPerMs = (deltaSec / dt);

    lastX = x;
    lastT = now;
  }

  function onUp(){
    if(!dragging) return;
    dragging = false;
    startInertia(); // ✅ 손 떼면 관성으로 조금 더 가다가 감속
  }

  // --- Pointer events (가능하면 이걸 사용)
  stage.addEventListener('pointerdown', (e)=>{
    stage.setPointerCapture?.(e.pointerId);
    onDown(e.clientX);
  }, {passive:false});

  stage.addEventListener('pointermove', (e)=>{
    e.preventDefault();
    onMove(e.clientX);
  }, {passive:false});

  stage.addEventListener('pointerup', onUp, {passive:true});
  stage.addEventListener('pointercancel', onUp, {passive:true});

  // --- iOS 일부 환경 fallback: touch events
  stage.addEventListener('touchstart', (e)=>{
    if(!e.touches?.length) return;
    onDown(e.touches[0].clientX);
  }, {passive:false});

  stage.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    if(!e.touches?.length) return;
    onMove(e.touches[0].clientX);
  }, {passive:false});

  stage.addEventListener('touchend', onUp, {passive:true});
  stage.addEventListener('touchcancel', onUp, {passive:true});

  // 메타 로드되면 준비
  video.addEventListener('loadedmetadata', ()=>{
    duration = video.duration || 0;
    ready = !!(duration && isFinite(duration));

    // 첫 프레임 표시 안정화(0은 가끔 검게 나오는 경우 있어 0.001)
    if(ready) setTime(0.001);
  });

  video.addEventListener('error', ()=>{
    ready = false;
    console.log("Video error:", video.error);
    console.log("Check URL:", VIDEO_URL);
  });
</script>
</body>
</html>
