<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Swipe Video Scrub</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      height: 100%;
      overflow: hidden;
    }

    .stage {
      position: fixed;
      inset: 0;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      box-sizing: border-box;

      display: flex;
      align-items: center;
      justify-content: center;

      height: 100svh;
      height: 100dvh;
      width: 100vw;

      /* iOS에서 touch-action만으로는 부족한 경우가 많아서 JS preventDefault와 같이 씀 */
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: contain;     /* 잘리지 않게 */
      background: #000;
      display: block;

      /* 핵심: 비디오 요소가 터치를 가로채지 않게 */
      pointer-events: none;

      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
    }
  </style>
</head>
<body>
  <div class="stage" id="stage">
    <video
      id="v"
      src="video.mp4"
      poster="poster.jpg"
      playsinline
      muted
      autoplay
      preload="auto"
    ></video>
  </div>

  <script>
    const video = document.getElementById("v");
    const stage = document.getElementById("stage");

    // ===== 튜닝(반응 더 시원하게) =====
    const SCREEN_WIDTHS_PER_FULL_LOOP = 0.55; // 더 빠르게(0.55~0.75)
    const FLICK_GAIN = 2.8;                   // 던질 때 더 멀리
    const FRICTION = 0.0018;                  // 관성 더 길게
    const MAX_VELOCITY_PX_PER_MS = 3.8;       // 최대 속도 캡

    let duration = 0;
    let ready = false;

    let down = false;
    let lastX = 0;
    let lastT = 0;
    let vx = 0;
    let inertiaRaf = 0;

    function modTime(t) {
      if (!duration || !isFinite(duration)) return 0;
      const eps = 0.0005;
      let x = t % duration;
      if (x < 0) x += duration;
      if (x >= duration) x = duration - eps;
      return x;
    }

    function secondsPerPixel() {
      const w = Math.max(1, window.innerWidth);
      return duration / (w * SCREEN_WIDTHS_PER_FULL_LOOP);
    }

    function stopInertia() {
      if (inertiaRaf) cancelAnimationFrame(inertiaRaf);
      inertiaRaf = 0;
    }

    function stepTo(newTime) {
      video.currentTime = modTime(newTime);
    }

    async function primeIOSVideo() {
      // iOS에서 스크럽 안정화: 유저 제스처 안에서 play->pause 한번
      try {
        await video.play();
        video.pause();
      } catch (_) {
        // autoplay 정책/상황에 따라 실패할 수 있음 (그래도 touch 이벤트는 유지)
      }
    }

    function onDown(clientX) {
      if (!ready) return;

      down = true;
      stopInertia();

      lastX = clientX;
      lastT = performance.now();
      vx = 0;

      // 첫 제스처 때 디코드 깨우기
      if (video.paused) primeIOSVideo();
    }

    function onMove(clientX) {
      if (!down || !ready) return;

      const now = performance.now();
      const dx = clientX - lastX;
      const dt = Math.max(1, now - lastT);

      const instV = dx / dt;        // px/ms
      vx = 0.75 * vx + 0.25 * instV;

      // dx>0(오른쪽) => 시간을 뒤로, dx<0(왼쪽) => 앞으로
      const base = (-dx) * secondsPerPixel();

      const speed = Math.min(MAX_VELOCITY_PX_PER_MS, Math.abs(vx));
      const gain = 1 + (speed * FLICK_GAIN);

      stepTo(video.currentTime + base * gain);

      lastX = clientX;
      lastT = now;
    }

    function onUp() {
      if (!down || !ready) return;
      down = false;

      let v = Math.max(-MAX_VELOCITY_PX_PER_MS, Math.min(MAX_VELOCITY_PX_PER_MS, vx));
      let last = performance.now();

      function tick() {
        const now = performance.now();
        const dt = now - last;
        last = now;

        const decay = Math.exp(-FRICTION * dt);
        v *= decay;

        if (Math.abs(v) < 0.02) {
          inertiaRaf = 0;
          return;
        }

        const ds = (-v) * secondsPerPixel() * dt;
        stepTo(video.currentTime + ds);

        inertiaRaf = requestAnimationFrame(tick);
      }

      inertiaRaf = requestAnimationFrame(tick);
    }

    // ===== iOS에서 핵심: passive:false + preventDefault =====
    function getTouchX(e) {
      const t = e.touches && e.touches[0];
      return t ? t.clientX : 0;
    }

    stage.addEventListener("touchstart", (e) => {
      if (e.cancelable) e.preventDefault();
      onDown(getTouchX(e));
    }, { passive: false });

    stage.addEventListener("touchmove", (e) => {
      if (e.cancelable) e.preventDefault();
      onMove(getTouchX(e));
    }, { passive: false });

    stage.addEventListener("touchend", (e) => {
      if (e.cancelable) e.preventDefault();
      onUp();
    }, { passive: false });

    stage.addEventListener("touchcancel", (e) => {
      if (e.cancelable) e.preventDefault();
      onUp();
    }, { passive: false });

    // 데스크탑 드래그
    stage.addEventListener("pointerdown", (e) => {
      stage.setPointerCapture?.(e.pointerId);
      onDown(e.clientX);
    });
    stage.addEventListener("pointermove", (e) => onMove(e.clientX));
    stage.addEventListener("pointerup", () => onUp());
    stage.addEventListener("pointercancel", () => onUp());

    // ===== 비디오 준비 =====
    video.addEventListener("loadedmetadata", () => {
      duration = video.duration || 0;
      ready = !!duration;

      // autoplay로 로드만 시키고 바로 pause (스크럽 모드)
      try { video.pause(); } catch (_) {}

      // 첫 프레임 확정
      stepTo(0);
    });

    // iOS에서 autoplay 성공해도 pause로 돌려놓기
    video.addEventListener("play", () => {
      setTimeout(() => { try { video.pause(); } catch (_) {} }, 0);
    });
  </script>
</body>
</html>
