<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#000000">

  <title>Swipe Scrub Loop + Inertia</title>

  <style>
    html, body { margin:0; padding:0; background:#000; }

    /* ✅ 주소창/하단바에 가려지지 않게: 100svh(작은 뷰포트) 우선 */
    #stage{
      position: fixed;
      left: 0; top: 0;
      width: 100vw;
      height: 100vh;   /* fallback */
      height: 100dvh;  /* 최신 */
      height: 100svh;  /* iOS 주소창 고려(가능하면 이 값이 적용되게 마지막에 둠) */

      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);

      display: grid;
      place-items: center;
      background: #000;
      overflow: hidden;

      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    /* ✅ “잘리지 않게” 보이려면 contain */
    video{
      width: 100%;
      height: 100%;
      object-fit: contain;  /* << 핵심: cover -> contain */
      display: block;
      background: #000;
      pointer-events: none; /* stage가 제스처 받게 */
    }
  </style>
</head>

<body>
  <div id="stage">
    <video id="v"
      src="video.mp4"
      preload="metadata"
      playsinline
      muted
      poster="poster.jpg"
    ></video>
  </div>

  <script>
    const stage = document.getElementById('stage');
    const v = document.getElementById('v');

    // ========= 튜닝 =========
    const SECONDS_PER_PX = 0.014;   // 손가락 이동 → 시간 변화(↑ 더 민감/빠름)
    const FLING_GAIN = 1.8;         // 던지기 세기(↑ 더 휘리릭)
    const DECAY_PER_SEC = 5.0;      // 감속(↓ 더 오래 미끄러짐)
    const MIN_FLING_VEL = 80;       // 관성 발동 최소 속도(px/s) (↓ 더 쉽게 발동)
    const EPS = 0.01;               // 디코더 안정용(0, duration 정확히 피하기)
    // =======================

    function dur() {
      return (isFinite(v.duration) && v.duration > 0) ? v.duration : NaN;
    }

    // ✅ 360도 회전 느낌의 핵심: 타임라인을 "무한 루프"로 래핑
    function wrapTime(t){
      const d = dur();
      if (!isFinite(d)) return 0;

      // modulo wrap: 0..d
      t = ((t % d) + d) % d;

      // 0 또는 d에 정확히 붙으면 iOS에서 검정/튐이 나올 수 있어 살짝 피함
      if (t < EPS) t = EPS;
      if (t > d - EPS) t = d - EPS;
      return t;
    }

    // iOS: 메타데이터 로드 후 첫 위치 고정
    v.addEventListener('loadedmetadata', () => {
      try { v.pause(); v.currentTime = wrapTime(0); } catch {}
    });

    // ===== 관성 =====
    let raf = 0;
    function stopInertia(){
      if (raf) cancelAnimationFrame(raf);
      raf = 0;
    }

    function startInertia(velPxPerSec){
      stopInertia();
      if (!isFinite(dur())) return;

      let vpx = velPxPerSec * FLING_GAIN; // px/s
      let last = performance.now();

      const step = (now) => {
        const dt = (now - last) / 1000;
        last = now;

        vpx *= Math.exp(-DECAY_PER_SEC * dt);
        if (Math.abs(vpx) < 5) { stopInertia(); return; }

        const deltaSeconds = vpx * SECONDS_PER_PX * dt;
        v.currentTime = wrapTime(v.currentTime + deltaSeconds);
        v.pause();

        raf = requestAnimationFrame(step);
      };

      raf = requestAnimationFrame(step);
    }

    // ===== 드래그 + 속도 추정(최근 샘플 평균으로 플링 안정화) =====
    let dragging = false;
    let lastX = 0;
    let samples = []; // {t, x}

    function addSample(x){
      const t = performance.now();
      samples.push({t, x});
      // 최근 120ms만 유지
      const cutoff = t - 120;
      while (samples.length && samples[0].t < cutoff) samples.shift();
      if (samples.length > 10) samples.shift();
    }

    function computeVelocity(){
      if (samples.length < 2) return 0;
      const a = samples[0];
      const b = samples[samples.length - 1];
      const dt = (b.t - a.t) / 1000;
      if (dt <= 0) return 0;
      return (b.x - a.x) / dt; // px/s
    }

    function onDown(clientX, pointerId){
      stopInertia();
      dragging = true;
      lastX = clientX;
      samples = [];
      addSample(clientX);

      // iOS 안정화: 사용자 제스처에서 play/pause 한 번 시도
      const p = v.play();
      if (p && p.then) p.then(()=>v.pause()).catch(()=>{});
      else { try { v.pause(); } catch {} }

      if (pointerId != null && stage.setPointerCapture) {
        try { stage.setPointerCapture(pointerId); } catch {}
      }
    }

    function onMove(clientX){
      if (!dragging) return;
      if (!isFinite(dur())) return;

      const dx = clientX - lastX;
      lastX = clientX;
      addSample(clientX);

      // dx -> time (루프이므로 엣지 데드존 없음)
      v.currentTime = wrapTime(v.currentTime + dx * SECONDS_PER_PX);
      v.pause();
    }

    function onUp(){
      if (!dragging) return;
      dragging = false;

      const vel = computeVelocity(); // px/s
      if (Math.abs(vel) >= MIN_FLING_VEL) {
        startInertia(vel);
      }
    }

    // Pointer events
    stage.addEventListener('pointerdown', (e) => { e.preventDefault(); onDown(e.clientX, e.pointerId); });
    stage.addEventListener('pointermove', (e) => { e.preventDefault(); onMove(e.clientX); });
    stage.addEventListener('pointerup',   (e) => { e.preventDefault(); onUp(); });
    stage.addEventListener('pointercancel', (e) => { e.preventDefault(); onUp(); });

    // Touch fallback (혹시 pointer가 끊기는 기기 대비)
    stage.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      if (t) onDown(t.clientX, null);
    }, {passive:false});

    stage.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const t = e.touches[0];
      if (t) onMove(t.clientX);
    }, {passive:false});

    stage.addEventListener('touchend', (e) => { e.preventDefault(); onUp(); }, {passive:false});
    stage.addEventListener('touchcancel', (e) => { e.preventDefault(); onUp(); }, {passive:false});
  </script>
</body>
</html>
