<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <!-- ✅ iOS 풀스크린 영역 최대 활용 -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover" />

  <!-- ✅ 홈화면(PWA)로 추가했을 때 풀스크린 -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">

  <title>Swipe Scrub</title>

  <style>
    html, body { margin:0; padding:0; background:#000; }

    /* iOS 주소창 변화 대응: 100dvh 사용 */
    #stage{
      position: fixed;
      left:0; top:0; right:0; bottom:0;
      height: 100dvh;
      width: 100vw;

      /* safe-area(노치/홈바) 보정 */
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);

      display:grid;
      place-items:center;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
      overflow:hidden;
      background:#000;
    }

    video{
      width: 100%;
      height: 100%;
      display:block;
      background:#000;
      pointer-events:none;

      /* ✅ 여백 없이 꽉 채우려면 cover / 여백 허용이면 contain */
      object-fit: cover; /* <- contain으로 바꾸면 레터박스(검정 여백) 생김 */
    }
  </style>
</head>
<body>
  <div id="stage">
    <video id="v"
      src="video.mp4"
      preload="metadata"
      playsinline
      muted
      poster="poster.jpg"
    ></video>
  </div>

  <script>
    const stage = document.getElementById('stage');
    const v = document.getElementById('v');

    // ===== 튜닝 =====
    const SECONDS_PER_PX = 0.012;
    const FLING_GAIN = 1.4;
    const DECAY_PER_SEC = 6.5;
    const MIN_FLING_VEL = 140;
    const EPS = 0.015; // 시작/끝 데드존 완화
    // ==============

    function dur() {
      return (isFinite(v.duration) && v.duration > 0) ? v.duration : NaN;
    }

    function clampTime(t){
      const d = dur();
      if (!isFinite(d)) return 0;
      const lo = 0 + EPS;
      const hi = d - EPS;
      return Math.max(lo, Math.min(hi, t));
    }

    // ✅ iOS에서 첫 프레임 표시 안정화: 메타데이터/첫 프레임 로드되면 위치 고정
    v.addEventListener('loadedmetadata', () => {
      try { v.pause(); v.currentTime = clampTime(0); } catch {}
    });

    // ===== 관성 =====
    let raf = 0;
    function stopInertia(){
      if (raf) cancelAnimationFrame(raf);
      raf = 0;
    }

    function startInertia(velPxPerSec){
      stopInertia();
      if (!isFinite(dur())) return;

      let vpx = velPxPerSec * FLING_GAIN;
      let last = performance.now();

      const step = (now) => {
        const dt = (now - last) / 1000;
        last = now;

        vpx *= Math.exp(-DECAY_PER_SEC * dt);
        if (Math.abs(vpx) < 8) { stopInertia(); return; }

        const deltaSeconds = vpx * SECONDS_PER_PX * dt;
        const next = clampTime(v.currentTime + deltaSeconds);

        const stuck = Math.abs(next - v.currentTime) < 1e-6;
        v.currentTime = next;
        v.pause();

        if (stuck) { stopInertia(); return; }
        raf = requestAnimationFrame(step);
      };
      raf = requestAnimationFrame(step);
    }

    // ===== 드래그(엣지에서 어느 방향이든 작동하도록 방향 자동반전) =====
    let dragging=false, lastX=0, lastT=0, vel=0;

    function applyDragDx(dx){
      if (!isFinite(dur())) return;

      let delta = dx * SECONDS_PER_PX;
      let next = clampTime(v.currentTime + delta);

      // 엣지에서 안 움직이면 반대로 적용(“어느 방향이든 컨트롤”)
      if (Math.abs(next - v.currentTime) < 1e-6) {
        delta = (-dx) * SECONDS_PER_PX;
        next = clampTime(v.currentTime + delta);
      }
      if (Math.abs(next - v.currentTime) < 1e-6) return;

      v.currentTime = next;
      v.pause();
    }

    stage.addEventListener('pointerdown', (e) => {
      stopInertia();
      stage.setPointerCapture(e.pointerId);
      dragging=true;
      lastX=e.clientX;
      lastT=performance.now();
      vel=0;

      // iOS 안정화(제스처 이후 play/pause 시도)
      const p = v.play();
      if (p && p.then) p.then(()=>v.pause()).catch(()=>{});
      else { try { v.pause(); } catch {} }

      e.preventDefault();
    });

    stage.addEventListener('pointermove', (e) => {
      if (!dragging) return;
      if (!isFinite(dur())) return;

      const now=performance.now();
      const dx=e.clientX-lastX;
      const dt=now-lastT;

      lastX=e.clientX;
      lastT=now;

      const before=v.currentTime;
      applyDragDx(dx);

      // 속도 추정(실제 이동 방향 기준)
      if (dt>0 && Math.abs(v.currentTime-before)>1e-6) {
        const sign = Math.sign(v.currentTime - before) || 1;
        const dxEff = Math.abs(dx) * sign;
        const inst = (dxEff/dt)*1000;
        vel = vel*0.8 + inst*0.2;
      }

      e.preventDefault();
    });

    function endDrag(){
      if (!dragging) return;
      dragging=false;
      if (Math.abs(vel) >= MIN_FLING_VEL) startInertia(vel);
    }
    stage.addEventListener('pointerup', endDrag);
    stage.addEventListener('pointercancel', endDrag);
  </script>
</body>
</html>
