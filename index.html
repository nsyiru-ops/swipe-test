<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#000000" />
  <title>Swipe Video Scrub</title>

  <style>
    html, body{
      margin:0; padding:0;
      width:100%; height:100%;
      background:#000;
      overflow:hidden;
      overscroll-behavior:none;
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;
    }

    :root{ --vh: 1vh; }

    #stage{
      position:fixed;
      inset:0;
      width:100%;
      height:calc(var(--vh) * 100);
      background:#000;
      display:flex;
      align-items:center;
      justify-content:center;
      padding-top:env(safe-area-inset-top);
      padding-bottom:env(safe-area-inset-bottom);
      padding-left:env(safe-area-inset-left);
      padding-right:env(safe-area-inset-right);
      box-sizing:border-box;
    }

    video{
      width:100%;
      height:100%;
      object-fit:contain; /* 발/구두 안 잘리게 */
      background:#000;
      display:block;
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
    }

    /* 검정 깜빡임 방지용 포스터 오버레이 */
    #posterOverlay{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      object-fit:contain;
      background:#000;
      pointer-events:none;
      display:block;
    }

    /* 아주 작은 디버그(필요 없으면 삭제해도 됨) */
    #tapToStart{
      position:fixed;
      left:50%;
      bottom:calc(env(safe-area-inset-bottom) + 16px);
      transform:translateX(-50%);
      padding:10px 14px;
      border-radius:999px;
      font:13px/1.2 -apple-system, system-ui, sans-serif;
      background:rgba(0,0,0,0.35);
      color:rgba(255,255,255,0.88);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      pointer-events:none;
      opacity:0;
      transition:opacity .2s ease;
    }
    #tapToStart.show{ opacity:1; }
  </style>
</head>

<body>
  <div id="stage">
    <video id="v"
      playsinline webkit-playsinline
      preload="auto"
      muted
      poster="poster.jpg"
    ></video>
    <img id="posterOverlay" src="poster.jpg" alt="">
  </div>

  <div id="tapToStart">처음 1회 터치로 준비</div>

<script>
  // ====== GitHub Pages에 같은 폴더로 업로드했으면 상대경로로 끝 ======
  const VIDEO_SRC = "video.mp4";

  const stage  = document.getElementById('stage');
  const video  = document.getElementById('v');
  const poster = document.getElementById('posterOverlay');
  const tip    = document.getElementById('tapToStart');

  video.src = VIDEO_SRC;

  // iOS 주소창/툴바 높이 변화 대응
  function setVh(){
    const h = (window.visualViewport?.height ?? window.innerHeight);
    document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
  }
  window.addEventListener('resize', setVh, {passive:true});
  window.visualViewport?.addEventListener('resize', setVh, {passive:true});
  setVh();

  // ====== 느낌(속도/가감속) 튜닝 ======
  // "시원시원" + "가감속 크게"
  const SECONDS_PER_PX = 0.0024; // 드래그 반응 속도 (↑ 더 빠름)
  const FRICTION       = 0.955;  // 관성 길이 (↑ 더 오래 미끄러짐)
  const STOP_V         = 0.000010; // 멈춤 임계 (↓ 더 오래 감)
  const RELEASE_BOOST  = 1.75;   // 손 떼는 순간 속도 부스트
  const MAX_STEP_SEC   = 0.12;   // 한 프레임 최대 이동(너무 튀는 것 방지)

  // ====== 상태 ======
  let unlocked = false;
  let ready = false;
  let duration = 0;

  let dragging = false;
  let lastX = 0;
  let lastT = 0;
  let velSecPerMs = 0;

  // 부드럽게: move 이벤트마다 currentTime을 때리지 않고 RAF에서 1회만 적용
  let desiredTime = 0;
  let applyRaf = 0;

  // 관성 RAF
  let inertiaRaf = 0;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  function getDurationSafe(){
    const d = video.duration;
    if (isFinite(d) && d > 0) return d;
    try {
      if (video.seekable && video.seekable.length) return video.seekable.end(0);
    } catch(e){}
    return 0;
  }

  function wrapTime(t){
    if (!duration || !isFinite(duration)) return 0;
    t = t % duration;
    if (t < 0) t += duration;
    return t;
  }

  // Safari는 fastSeek가 있으면 더 안정적일 때가 있음
  function setTime(t){
    if (!ready) return;
    const nt = wrapTime(t);

    // 너무 촘촘하게 때리면 decode가 밀려 "끊김"이 심해질 수 있어 약간 문턱
    // (그래도 반응성 유지하도록 아주 낮게)
    const cur = video.currentTime || 0;
    if (Math.abs(nt - cur) < 0.0004) return;

    try{
      if (typeof video.fastSeek === "function") video.fastSeek(nt);
      else video.currentTime = nt;
    }catch(e){}
  }

  function scheduleApply(){
    if (applyRaf) return;
    applyRaf = requestAnimationFrame(()=>{
      applyRaf = 0;
      setTime(desiredTime);
    });
  }

  // iOS: 첫 제스처에서 play→pause로 "언락"해야 스크럽이 잘 됨
  async function unlockOnce(){
    if (unlocked) return;
    unlocked = true;

    tip.classList.remove('show');

    try{
      video.muted = true;
      const p = video.play();
      if (p && p.then) await p;
      video.pause();
    }catch(e){
      // 정책/상황에 따라 실패할 수 있어도 스크럽은 시도
    }

    // 메타 준비 체크
    const tryReady = ()=>{
      duration = getDurationSafe();
      if (duration > 0){
        ready = true;
        desiredTime = 0.001;
        scheduleApply();
        // 첫 프레임이 뜰 타이밍에 포스터 숨김
        setTimeout(()=>{ poster.style.display = "none"; }, 60);
      } else {
        // 아직 준비 안 됐으면 다시
        setTimeout(tryReady, 150);
      }
    };
    tryReady();
  }

  // 메타 이벤트
  video.addEventListener('loadedmetadata', ()=>{
    duration = getDurationSafe();
    ready = duration > 0;
  });
  video.addEventListener('canplay', ()=>{
    duration = getDurationSafe();
    ready = duration > 0;
  });

  video.addEventListener('error', ()=>{
    ready = false;
    poster.style.display = "block";
    tip.textContent = "video.mp4 로드 실패(경로/업로드 확인)";
    tip.classList.add('show');
    console.log("Video error:", video.error);
  });

  // 관성
  function stopInertia(){
    if (inertiaRaf) cancelAnimationFrame(inertiaRaf);
    inertiaRaf = 0;
  }

  function startInertia(){
    stopInertia();
    let prev = performance.now();

    const step = (now)=>{
      const dt = now - prev;
      prev = now;

      if (!ready) { inertiaRaf = 0; return; }
      if (Math.abs(velSecPerMs) < STOP_V){
        velSecPerMs = 0;
        inertiaRaf = 0;
        return;
      }

      // 이동량 제한
      const delta = clamp(velSecPerMs * dt, -MAX_STEP_SEC, MAX_STEP_SEC);
      desiredTime = (video.currentTime || 0) + delta;
      scheduleApply();

      // 감속(프레임 보정)
      const f = Math.pow(FRICTION, dt / 16.67);
      velSecPerMs *= f;

      inertiaRaf = requestAnimationFrame(step);
    };
    inertiaRaf = requestAnimationFrame(step);
  }

  // 입력
  function onDown(x){
    unlockOnce();
    dragging = true;
    lastX = x;
    lastT = performance.now();
    velSecPerMs = 0;
    stopInertia();
  }

  function onMove(x){
    if (!dragging || !ready) return;

    const now = performance.now();
    const dx = x - lastX;
    const dt = Math.max(1, now - lastT);

    // 왼쪽 스와이프=앞으로(+), 오른쪽=뒤로(-) 느낌이 싫으면 부호만 바꾸면 됨
    const deltaSec = (-dx) * SECONDS_PER_PX;

    desiredTime = (video.currentTime || 0) + deltaSec;
    scheduleApply();

    velSecPerMs = (deltaSec / dt);

    lastX = x;
    lastT = now;
  }

  function onUp(){
    if (!dragging) return;
    dragging = false;

    // 던지는 느낌 크게
    velSecPerMs *= RELEASE_BOOST;

    startInertia();
  }

  // 안내: iOS에서 최초 1회 터치 필요할 때 표시
  setTimeout(()=>{
    if (!unlocked) tip.classList.add('show');
  }, 400);

  // Pointer events
  stage.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    stage.setPointerCapture?.(e.pointerId);
    onDown(e.clientX);
  }, {passive:false});

  stage.addEventListener('pointermove', (e)=>{
    e.preventDefault();
    onMove(e.clientX);
  }, {passive:false});

  stage.addEventListener('pointerup', (e)=>{ onUp(); }, {passive:true});
  stage.addEventListener('pointercancel', (e)=>{ onUp(); }, {passive:true});

  // Touch fallback
  stage.addEventListener('touchstart', (e)=>{
    e.preventDefault();
    if (!e.touches?.length) return;
    onDown(e.touches[0].clientX);
  }, {passive:false});

  stage.addEventListener('touchmove', (e)=>{
    e.preventDefault();
    if (!e.touches?.length) return;
    onMove(e.touches[0].clientX);
  }, {passive:false});

  stage.addEventListener('touchend', (e)=>{ onUp(); }, {passive:true});
  stage.addEventListener('touchcancel', (e)=>{ onUp(); }, {passive:true});
</script>
</body>
</html>
