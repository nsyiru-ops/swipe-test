<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#000000" />
  <title>Swipe Video Scrub</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: #000;
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none;
    }
    /* iOS 안전영역 포함한 풀스크린 */
    #stage {
      position: fixed;
      inset: 0;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: #000;
      /* 잘림 방지: 화면 안에 "맞춰" 보이게 */
      object-fit: contain;
    }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="c"></canvas>
  </div>

  <script>
    // ===== 파일명/포스터 =====
    const VIDEO_URL = "https://zippy-flan-5b618a.netlify.app/video.mp4";
    const POSTER_URL = "poster.jpg";

    // ===== 튜닝값(시원시원 + 관성 크게) =====
    const SECONDS_PER_PX = 0.0022;    // ⬅️ 스와이프 2.4배 빠르게(대략)
    const FRICTION = 0.94;            // ⬅️ 관성 길게
    const STOP_V = 0.000012;          // ⬅️ 더 늦게 멈춤
    const RELEASE_BOOST = 1.6;        // ⬅️ 손 떼는 순간 "던지는" 느낌 부스트
    const MAX_STEP_SEC = 0.09;        // ⬅️ 한 프레임에서 너무 튀는 것 방지

    // ===== 캔버스/비디오 준비 =====
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d", { alpha: false });

    const vid = document.createElement("video");
    vid.playsInline = true;
    vid.muted = true;         // iOS 정책상 안전
    vid.preload = "auto";
    vid.crossOrigin = "anonymous";
    vid.src = VIDEO_URL;

    // poster(첫 화면용)
    const poster = new Image();
    poster.src = POSTER_URL;

    let vw = 0, vh = 0;       // 비디오 원본 크기
    let duration = 0;
    let ready = false;

    function resize() {
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawFrame(); // 리사이즈 시 즉시 갱신
    }
    window.addEventListener("resize", resize, { passive: true });
    resize();

    function drawToCanvas(source) {
      const w = window.innerWidth;
      const h = window.innerHeight;

      // contain: 화면 안에 맞추기(잘림 방지)
      const sw = source.videoWidth ? source.videoWidth : source.width;
      const sh = source.videoHeight ? source.videoHeight : source.height;
      if (!sw || !sh) return;

      const sAspect = sw / sh;
      const dAspect = w / h;

      let dw, dh, dx, dy;
      if (sAspect > dAspect) {
        dw = w;
        dh = w / sAspect;
        dx = 0;
        dy = (h - dh) / 2;
      } else {
        dh = h;
        dw = h * sAspect;
        dy = 0;
        dx = (w - dw) / 2;
      }

      ctx.clearRect(0, 0, w, h);
      ctx.drawImage(source, dx, dy, dw, dh);
    }

    function drawFrame() {
      if (ready) drawToCanvas(vid);
      else if (poster.complete) drawToCanvas(poster);
    }

    // iOS에서 metadata 로드 전에는 duration이 NaN일 수 있음
    vid.addEventListener("loadedmetadata", () => {
      vw = vid.videoWidth;
      vh = vid.videoHeight;
      duration = vid.duration || 0;
    });

    // 첫 프레임 확보 (iOS는 사용자 제스처 필요할 때가 많아서, poster로 시작)
    async function ensureVideoReadyByGesture() {
      if (ready) return true;
      try {
        // 0초로 한 번 세팅하고, 프레임이 그려질 수 있게 대기
        if (isFinite(vid.duration) && vid.duration > 0) duration = vid.duration;
        vid.currentTime = 0;
        await once(vid, "seeked", 800);
        ready = true;
        drawFrame();
        return true;
      } catch (e) {
        // 그래도 poster는 보이게
        ready = false;
        drawFrame();
        return false;
      }
    }

    function once(el, ev, timeoutMs = 1200) {
      return new Promise((resolve, reject) => {
        const t = setTimeout(() => {
          cleanup();
          reject(new Error("timeout"));
        }, timeoutMs);

        function cleanup() {
          clearTimeout(t);
          el.removeEventListener(ev, on, true);
        }
        function on() {
          cleanup();
          resolve();
        }
        el.addEventListener(ev, on, true);
      });
    }

    // ===== 스와이프/관성 로직 =====
    let dragging = false;
    let lastX = 0;
    let lastT = 0;

    // 속도(초/밀리초)
    let velSecPerMs = 0;
    let inertiaRAF = 0;

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function wrapTime(t) {
      if (!duration || !isFinite(duration)) return 0;
      t = t % duration;
      if (t < 0) t += duration;
      return t;
    }

    function stopInertia() {
      if (inertiaRAF) cancelAnimationFrame(inertiaRAF);
      inertiaRAF = 0;
    }

    function startInertia() {
      stopInertia();
      let last = performance.now();

      const tick = (now) => {
        const dtMs = now - last;
        last = now;

        // 느려졌으면 정지
        if (Math.abs(velSecPerMs) < STOP_V) {
          velSecPerMs = 0;
          inertiaRAF = 0;
          return;
        }

        // 진행
        const step = clamp(velSecPerMs * dtMs, -MAX_STEP_SEC, MAX_STEP_SEC);
        const nt = wrapTime(vid.currentTime + step);
        vid.currentTime = nt;

        // 감속
        velSecPerMs *= Math.pow(FRICTION, dtMs / 16.67);

        // 프레임 그리기: seeked 기다리지 않고 rAF로 계속 갱신(끊김 줄이기)
        drawFrame();
        inertiaRAF = requestAnimationFrame(tick);
      };

      inertiaRAF = requestAnimationFrame(tick);
    }

    function onDown(clientX) {
      dragging = true;
      stopInertia();
      velSecPerMs = 0;
      lastX = clientX;
      lastT = performance.now();
    }

    function onMove(clientX) {
      if (!dragging) return;

      const now = performance.now();
      const dx = clientX - lastX;
      const dt = Math.max(1, now - lastT);

      // 손가락 이동 → 시간 이동(루프)
      const deltaSec = dx * SECONDS_PER_PX;
      const nt = wrapTime((vid.currentTime || 0) + deltaSec);
      vid.currentTime = nt;

      // 관성용 속도 추정(초/밀리초)
      velSecPerMs = deltaSec / dt;

      lastX = clientX;
      lastT = now;

      drawFrame();
    }

    function onUp() {
      if (!dragging) return;
      dragging = false;

      // ⬅️ 손 떼는 순간 "던지는" 관성 강화
      velSecPerMs *= RELEASE_BOOST;

      startInertia();
    }

    // ===== 이벤트: Pointer(데스크톱) + Touch(iOS) =====
    const stage = document.getElementById("stage");

    // iOS에서 첫 제스처로 비디오 준비
    stage.addEventListener("pointerdown", async (e) => {
      e.preventDefault();
      await ensureVideoReadyByGesture();
      onDown(e.clientX);
      stage.setPointerCapture?.(e.pointerId);
    }, { passive: false });

    stage.addEventListener("pointermove", (e) => {
      e.preventDefault();
      onMove(e.clientX);
    }, { passive: false });

    stage.addEventListener("pointerup", (e) => {
      e.preventDefault();
      onUp();
    }, { passive: false });

    stage.addEventListener("pointercancel", (e) => {
      e.preventDefault();
      onUp();
    }, { passive: false });

    // iOS Safari에서 pointer가 불안정할 때 대비(터치 보강)
    stage.addEventListener("touchstart", async (e) => {
      e.preventDefault();
      await ensureVideoReadyByGesture();
      const t = e.touches[0];
      if (t) onDown(t.clientX);
    }, { passive: false });

    stage.addEventListener("touchmove", (e) => {
      e.preventDefault();
      const t = e.touches[0];
      if (t) onMove(t.clientX);
    }, { passive: false });

    stage.addEventListener("touchend", (e) => {
      e.preventDefault();
      onUp();
    }, { passive: false });

    stage.addEventListener("touchcancel", (e) => {
      e.preventDefault();
      onUp();
    }, { passive: false });

    // poster가 먼저 떠 있도록
    poster.onload = () => drawFrame();

    // (선택) 데스크톱에서 바로 로드되면 metadata라도 미리 확보
    vid.load();
  </script>
</body>
</html>
